import sys
import os
import time
from twisted.python import log, monkey
from twisted.application import service
from twisted.internet import reactor
from buildslave import bot

# states for use below (using symbols prevents typos)

STOPPED = "stopped"
DISCONNECTED = "disconnected"
CONNECTED = "connected"

class Idleizer(service.Service):
    """
    A service that will monitor a buildslave instance for idleness and
    disconnectedness, and gracefully restart it if either of those goes on for
    longer than a configured time.

    This is intended to be instantiated directly in buildbot.tac.
    """
    def __init__(self, buildslave_svc, max_idle_time=None, max_disconnected_time=None):
        """
        Create a service.  C{buildslave_svc} should be the
        L{buildslave.bot.BuildSlave} instance created in C{buildbot.tac}.
        C{max_idle_time} is the maximum time, in seconds, that the slave will
        be allowed to idle before it is restarted.  Similarly,
        C{max_disconnected_time} is the maximum time it will be allowed to go
        without a connection to a master.

        "Idle" is defined as not beginning a step.  Note that this will *not*
        kill a long-running step, because a graceful restart will wait until
        the build is complete.
        """
        self.buildslave_svc = buildslave_svc
        self.max_idle_time = max_idle_time
        self.max_disconnected_time = max_disconnected_time

        self._timer = None
        self._state = STOPPED

        # don't reboot unless this class requested the stop
        self._reboot_on_shutdown = False

        self._setUpMonkeyPatches()

    def startService(self):
        self._monkey.patch()
        self.changeState(DISCONNECTED)

    def stopService(self):
        self.changeState(STOPPED)
        self._monkey.restore()

    def _clearTimer(self):
        if self._timer:
            self._timer.cancel()
        self._timer = None

    def _setTimer(self, when):
        self._clearTimer()
        def fired():
            self._timer = None
            self.doRestart()
        self._timer = reactor.callLater(when, fired)

    def changeState(self, new_state):
        if new_state == self._state:
            return

        self._clearTimer()

        self._state = new_state
        if new_state == CONNECTED:
            self._setTimer(self.max_idle_time)
        elif new_state == DISCONNECTED:
            self._setTimer(self.max_disconnected_time)

    def registerActivity(self):
        if self._state == CONNECTED:
            # just reset the timer
            self._setTimer(self.max_idle_time)
        else:
            log.msg("Idleizer: activity while not connected??")

    def maybeReboot(self):
        if self._reboot_on_shutdown:
            self.reboot()
        # note that the reactor.stop() will continue when this method returns

    def _setUpMonkeyPatches(self):
        self._monkey = monkey.MonkeyPatcher()

        def changeStateOn(obj, name, state):
            old_fn = getattr(obj, name)
            def new_fn(*args, **kwargs):
                self.changeState(state)
                return old_fn(*args, **kwargs)
            self._monkey.addPatch(obj, name, new_fn)

        # this is probably overkill, but it's good to be sure
        changeStateOn(self.buildslave_svc.bf,
                'gotPerspective', CONNECTED)
        changeStateOn(self.buildslave_svc.bf,
                'startedConnecting', DISCONNECTED)
        changeStateOn(self.buildslave_svc.bf,
                'clientConnectionFailed', DISCONNECTED)
        changeStateOn(self.buildslave_svc.bf,
                'clientConnectionLost', DISCONNECTED)

        def registerActivityOn(obj, name):
            old_fn = getattr(obj, name)
            def new_fn(*args, **kwargs):
                self.registerActivity()
                return old_fn(*args, **kwargs)
            self._monkey.addPatch(obj, name, new_fn)

        registerActivityOn(bot.SlaveBuilder, 'activity')

        def maybeRebootOn(obj, name):
            old_fn = getattr(obj, name)
            def new_fn(*args, **kwargs):
                self.maybeReboot()
                return old_fn(*args, **kwargs)
            self._monkey.addPatch(obj, name, new_fn)

        maybeRebootOn(bot.SlaveBuilder, 'remote_shutdown')
        maybeRebootOn(bot.Bot, 'remote_shutdown')

    def doRestart(self):
        log.msg("I feel very idle and was thinking of rebooting as soon as "
                "the buildmaster says it's OK")
        self._reboot_on_shutdown = True

        # this is a re-implementation of the gracefulShutdown method from
        # bot.py, with a few tweaks:
        # - if no perspective, reboot rather than calling reactor.stop
        # - if the callRemote fails, reboot immediately (this will always fail
        #   until we upgrade the masters to 0.8.3 or higher)

        if not self.buildslave_svc.bf.perspective:
            log.msg("No active connection, rebooting NOW")
            self.reboot()
            return

        log.msg("Telling the master we want to shutdown after any running builds are finished")
        d = self.buildslave_svc.bf.perspective.callRemote("shutdown")
        def _shutdownfailed(err):
            if err.check(AttributeError):
                log.msg("Master does not support slave initiated shutdown.  Upgrade master to 0.8.3 or later to use this feature.")
            else:
                log.msg('callRemote("shutdown") failed')
                log.err(err)
            log.msg("rebooting NOW, since the master won't talk to us")
            self.reboot()
        d.addErrback(_shutdownfailed)
        # if this deferred succeeds, then we'll get a call to remote_shutdown,
        # which will call self.reboot.

    def reboot(self):
        log.msg("Invoking platform-specific reboot command")
        if sys.platform in ('darwin', 'linux2'):
            # -S means to accept password from stdin, which we then redirect from
            # /dev/null
            # This results in sudo not waiting forever for a password.  If sudoers
            # isn't set up properly, this will fail immediately
            os.system("sudo -S reboot < /dev/null")

        # Windows
        elif sys.platform == "win32":
            os.system("shutdown -f -r -t 0")
        else:
            log.msg("unknown platform " + sys.platform)

        # After starting the shutdown, we just die.  If the shutdown fails, then
        # this should trigger some extra monitoring alerts
        reactor.stop()
